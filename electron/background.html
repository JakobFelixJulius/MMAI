<h1>Background</h1>
<script type="text/javascript">
	const {ipcRenderer} = require('electron');
	const mm = require('@magenta/music');

	const improvCheckpoint = 'https://storage.googleapis.com/magentadata/js/checkpoints/music_rnn/chord_pitches_improv';
	const improvRNN = new mm.MusicRNN(improvCheckpoint);
	improvRNN.initialize().then(() => ready());

	// Send logs as messages to the main thread to show on the console
	function log(value) {
		ipcRenderer.send('to-main', process.pid + ': ' + value);
	}

	// let the main thread know this thread is ready to process something
	function ready() {
		ipcRenderer.send('ready');
	}

	function generate(data) {
		modelGenerate(data).then((seq) => {
			// send data and message that generation is done
			log('finished generating sequence on bg thread from ' +
				'generator ' + data.id);
			ready();
			ipcRenderer.send('for-renderer', {data: seq, id: data.id});
		});
	}

	// if message is received, pass it back to the renderer via the
	// main thread
	ipcRenderer.on('message', (event, arg) => {
		log('received ' + arg);
		ipcRenderer.send('for-renderer', process.pid + ': reply to ' + arg);
		ready();
	});

	ipcRenderer.on('task', (event, arg) => {
		log('starting generation on bg thread from generator ' + arg.id);
		generate(arg);
	})

	function modelGenerate(data) {
    return new Promise(function(resolve, reject) {
       // Number of steps to play each chord.
		let stps_p_chrd = 8;
		let stps_p_prog = 4 * stps_p_chrd;

		// Number of times to repeat chord progression.
		let NUM_REPS = data.outputBars / 2;

		// const stepsPerQuarter = data.seq.quantizationInfo.stepsPerQuarter;
		// const steps = (stepsPerQuarter * data.outputBars * 4)-1;

		const steps = stps_p_prog + (NUM_REPS-1)*stps_p_prog - 1;
		improvRNN.continueSequence(data.seq, steps, data.temp, data.chords)
			.then((contSeq) => {
				let seq = {
					notes: [],
					quantizationInfo: {stepsPerQuarter: 4},
					totalQuantizedSteps: 1,
				};

				let loopThreshold = steps+1;

				// Add the continuation to the original.
				contSeq.notes.forEach((note) => {
					note.quantizedStartStep += 1;
					note.quantizedEndStep += 1;
					if (note.quantizedEndStep == loopThreshold) {
						// for looping to work, can't have an endstep
						// on 32/64/128
						note.quantizedEndStep -= 1;
					}
					seq.notes.push(note);
					});

				if (data.addBassProg) {
					const roots = data.chords.map(
						mm.chords.ChordSymbols.root);

					for (var i=0; i<NUM_REPS; i++) {
						// Add the bass progression.
						seq.notes.push({
							instrument: 1,
							program: 32,
							pitch: 36 + roots[0],
							quantizedStartStep: i*stps_p_prog,
							quantizedEndStep: i*stps_p_prog + stps_p_chrd
						});
						seq.notes.push({
							instrument: 1,
							program: 32,
							pitch: 36 + roots[1],
							quantizedStartStep: i*stps_p_prog + stps_p_chrd,
							quantizedEndStep: i*stps_p_prog + 2*stps_p_chrd
							});
						seq.notes.push({
							instrument: 1,
							program: 32,
							pitch: 36 + roots[2],
							quantizedStartStep: i*stps_p_prog +2*stps_p_chrd,
							quantizedEndStep: i*stps_p_prog +3*stps_p_chrd
						});
						seq.notes.push({
							instrument: 1,
							program: 32,
							pitch: 36 + roots[3],
							quantizedStartStep: i*stps_p_prog +3*stps_p_chrd,
							quantizedEndStep: i*stps_p_prog +4*stps_p_chrd -1
						});
					}
				}

				// Set total sequence length.
                seq.totalQuantizedSteps = (stps_p_prog * NUM_REPS) -1;

                resolve(seq);
			});
		});
	}
</script>